---
id: cses-1160
source: CSES
title: Planets Queries II
author: Dustin Miao, Michael Cao, Benjamin Qi
---

We are given a functional directed graph and asked $q$ queries for the minimum distance between two vertices $u$ and $v$, if it exists. 

## Solution

Decompose the graph into several cases. Note that because each node has one outgoing edge, there must be exactly one cycle in every connected component. 

Compress this cycle into a single node. Each connected component is now a tree, rooted at the cycle node. Consider a query for a path from $u$ to $v$. Assume that $u$ and $v$ are in the same component (otherwise, no path exits and the answer is $-1$). There are four cases to consider:

1. If $u$ and $v$ are both located within the cycle, then there is always a path between them. "Root" the cycle at a node within the cycle, and for each subsequent node, record the distance between that node at the cycle root. This kind of query can be processed in $\mathcal{O}(1)$ by subtracting the cycle distance information accordingly. 

2. If $u$ is in the cycle and $v$ is not in the cycle (ie in the tree), then there is no path between them. Nodes in the cycle can only reach other nodes in cycle via the edges. 

3. If $u$ is in the tree and $v$ is in the cycle, then there is an answer. By traversing the edges from $u$ until a node on the cycle is reached, this can be reduced to the first case. By itself, this method takes $\mathcal{O}(n)$ but it can be sped up to $\mathcal{O}(\log n)$ using techniques discussed later. 

4. If $u$ and $v$ are both on the tree, then it suffices to check if $v$ is an ancestor of $u$. Note that each node can only travel to edges that point towards the root. Once again, in the worst-case naive solution this may take up to $\mathcal{O}(n)$ but it can be sped up to $\mathcal{O}(\log n)$

For the third and fourth case, one possible optimization is to use binary lifting. Precompute the distance from the root to every node, and store it in each node. For the third query, simply jump up by that distance (and add it to the answer). For the fourth case, check if the node that is $\texttt{dis}(u) - \texttt{dis}(v)$ above $u$ is $v$ or not. 

## Implementation

**Time Complexity:** $\mathcal{O}((n + q) \log n)$

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 2e5 + 1;
const int LOGN = 20;

int N, Q, cycle_len[MAXN];

struct Node {
	int par[LOGN], cycle_id = 0, dis = 0, vis = 0;
	bool cycle = 0;
} node[MAXN];

pair<int, int> dfs(int u, int dfs_id) {
	if (node[u].vis) {
		if (node[u].vis == dfs_id) {  // cycle decomposition
			int v = u, d = 0;
			do {
				node[v].cycle = 1;
				node[v].cycle_id = u;
				node[v].dis = d++;
				v = node[v].par[0];
			} while (v != u);
			cycle_len[u] = d;
			return {0, u};
		} else {  // tree decomposition
			if (node[u].cycle) {
				return {node[u].cycle_id, 1};
			} else {
				return {node[u].cycle_id, node[u].dis + 1};
			}
		}
	}

	node[u].vis = dfs_id;
	pair<int, int> t = dfs(node[u].par[0], dfs_id);

	if (t.first == 0) {  // cycle decomposition
		if (t.second == u) {
			return {node[u].cycle_id, 1};
		} else {
			return t;
		}
	} else {  // tree decomposition
		node[u].cycle_id = t.first;
		node[u].dis = t.second;
		return {node[u].cycle_id, node[u].dis + 1};
	}
}

int main() {
	cin >> N >> Q;
	for (int i = 1; i <= N; i++) {
		cin >> node[i].par[0];
	}
	for (int i = 1; i <= N; i++) {
		dfs(i, i);
	}

	for (int k = 1; k < LOGN; k++) {
		for (int i = 1; i <= N; i++) {
			node[i].par[k] = node[node[i].par[k - 1]].par[k - 1];
		}
	}
	
	auto lift = [](int a, int d) {
		for (int i = LOGN - 1; i >= 0; i--) {
			if ((d >> i) & 1) {
				a = node[a].par[i];
			}
		}
		return a;
	};

	auto cycle_dis = [](int a, int b) {
		assert(node[a].cycle && node[b].cycle);
		assert(node[a].cycle_id == node[b].cycle_id);
		if (node[a].dis <= node[b].dis) {
			return node[b].dis - node[a].dis;
		} else {
			return cycle_len[node[a].cycle_id] - (node[a].dis - node[b].dis);
		}
	};

	for (int q = 0; q < Q; q++) {
		int a, b;
		cin >> a >> b;

		if (node[a].cycle && node[b].cycle) {
			if (node[a].cycle_id == node[b].cycle_id) {
				cout << cycle_dis(a, b) << '\n';
			} else {
				cout << -1 << '\n';
			}
		} else if (node[a].cycle && !node[b].cycle) {
			cout << -1 << '\n';
		} else if (!node[a].cycle && node[b].cycle) {
			if (node[a].cycle_id == node[b].cycle_id) {
				assert(node[lift(a, node[a].dis)].cycle);
				cout << node[a].dis + cycle_dis(lift(a, node[a].dis), b) << '\n';
			} else {
				cout << -1 << '\n';
			}
		} else if (!node[a].cycle && !node[b].cycle) {
			if (node[a].dis >= node[b].dis && lift(a, node[a].dis - node[b].dis) == b) {
				cout << node[a].dis - node[b].dis << '\n';
			} else {
				cout << -1 << '\n';
			}
		}
	}
}
```

</CPPSection>

</LanguageSection>
