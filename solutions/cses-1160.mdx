---
id: cses-1160
source: CSES
title: Planets Queries II
author: Dustin Miao, Michael Cao, Benjamin Qi
---

In this problem, we are given a functional directed graph and asked $q$ queries for the minimum distance between two vertices $u$ and $v$, if it exists. 

## Solution

We will decompose the graph into several cases. Note that because each node has one outgoing edge, there must be exactly one cycle in every connected component. 

Compress this cycle into a single node. Each connected component is now a tree, rooted at the cycle node. Consider a query for a path from $u$ to $v$. We will assume that $u$ and $v$ are in the same component (otherwise, clearly no path exits and the answer is $-1$). There are four main cases to consider:

1. If $u$ and $v$ are both located within the cycle, then there always a path between them. "Root" the cycle at a node within the cycle, and for each subsequent node, record the distance between that node at the cycle root. We can now process this kind of query in $\mathcal{O}(1)$ by subtracting the cycle distance information accordingly. 

2. If $u$ is in the cycle and $v$ is not in the cycle (ie in the tree), then there is no path between them. Nodes in the cycle can only reach other nodes in cycle via the edges. 

3. If $u$ is in the tree and $v$ is in the cycle, then there is an answer. If we traverse the edges from $u$ until we reach a node on the cycle, then we can reduce the problem to the first case. By itself, this method takes $\mathcal{O}(n)$ but we can speed it up to $\mathcal{O}(\log n)$ using techniques discussed later. 

4. If $u$ and $v$ are both on the tree, then it suffices to check if $v$ is an ancestor of $u$. Note that each node can only travel to edges that point towards the root. Once again, in the worst case naive solution this may take up to $\mathcal{O}(n)$ but we will speed it up to $\mathcal{O}(\log n)$

For the third and fourth case, one possible optimization is to use binary lifting. We can precompute the distance from the root to every node, and store it in each node. For the third query, we simply have to jump up by that distance (and add it to the answer). For the fourth case, we check if the node that is $\texttt{dis}(u) - \texttt{dis}(v)$ above $u$ is $v$ or not. 

## Implementation

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

int N, Q, cycle_len[200005];

struct node {
	int par[20], cycle_id = 0, dis = 0, vis = 0;
	bool cycle = 0;
} nde[200005];

pair<int, int> dfs(int u, int dfs_id) {
	if (nde[u].vis) {
		if (nde[u].vis == dfs_id) {  // cycle case
			int v = u, d = 0;
			do {
				nde[v].cycle = 1;
				nde[v].cycle_id = u;
				nde[v].dis = d++;
				v = nde[v].par[0];
			} while (v != u);
			cycle_len[u] = d;
			return {0, u};
		} else {  // regular case
			if (nde[u].cycle) {
				return {nde[u].cycle_id, 1};
			} else {
				return {nde[u].cycle_id, nde[u].dis + 1};
			}
		}
	}

	nde[u].vis = dfs_id;
	auto t = dfs(nde[u].par[0], dfs_id);

	if (t.first == 0) {  // cycle case
		if (t.second == u) {
			return {nde[u].cycle_id, 1};
		} else {
			return t;
		}
	} else {  // regular case
		nde[u].cycle_id = t.first;
		nde[u].dis = t.second;
		return {nde[u].cycle_id, nde[u].dis + 1};
	}
}

int main() {
	cin >> N >> Q;
	for (int i = 1; i <= N; i++) {
		cin >> nde[i].par[0];
	}
	for (int i = 1; i <= N; i++) {
		dfs(i, i);
	}

	for (int k = 1; k < 20; k++) {
		for (int i = 1; i <= N; i++) {
			nde[i].par[k] = nde[nde[i].par[k - 1]].par[k - 1];
		}
	}
	
	auto lift = [](int a, int d) {
		for (int i = 19; i >= 0; i--) {
			if ((d >> i) & 1) {
				a = nde[a].par[i];
			}
		}
		return a;
	};

	auto cycle_dis = [](int a, int b) {
		assert(nde[a].cycle && nde[b].cycle);
		assert(nde[a].cycle_id == nde[b].cycle_id);
		if (nde[a].dis <= nde[b].dis) {
			return nde[b].dis - nde[a].dis;
		} else {
			return cycle_len[nde[a].cycle_id] - (nde[a].dis - nde[b].dis);
		}
	};

	while (Q--) {
		int a, b;
		cin >> a >> b;

		if (nde[a].cycle && nde[b].cycle) {  // case 1
			if (nde[a].cycle_id == nde[b].cycle_id) {
				cout << cycle_dis(a, b) << '\n';
			} else {
				cout << -1 << '\n';
			}
		}
		else if (nde[a].cycle && !nde[b].cycle) {  // case 2
			cout << -1 << '\n';
		}
		else if (!nde[a].cycle && nde[b].cycle) {  // case 3
			if (nde[a].cycle_id == nde[b].cycle_id) {
				assert(nde[lift(a, nde[a].dis)].cycle);
				cout << nde[a].dis + cycle_dis(lift(a, nde[a].dis), b) << '\n';
			} else {
				cout << -1 << '\n';
			}
		}
		else if (!nde[a].cycle && !nde[b].cycle) {  // case 4
			if (nde[a].dis >= nde[b].dis && lift(a, nde[a].dis - nde[b].dis) == b) {
				cout << nde[a].dis - nde[b].dis << '\n';
			} else {
				cout << -1 << '\n';
			}
		}
	}
}
```

</CPPSection>

</LanguageSection>
